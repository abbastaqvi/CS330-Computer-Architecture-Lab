$date
	Fri Apr 08 11:02:13 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module RISC_V_Pr_tb $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$scope module RISCV $end
$var wire 4 # Funct [3:0] $end
$var wire 64 $ PC_In [63:0] $end
$var wire 64 % WriteData [63:0] $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 5 & rs2 [4:0] $end
$var wire 5 ' rs1 [4:0] $end
$var wire 5 ( rd [4:0] $end
$var wire 32 ) instruction [31:0] $end
$var wire 64 * imm_data [63:0] $end
$var wire 7 + funct7 [6:0] $end
$var wire 3 , funct3 [2:0] $end
$var wire 1 - Zero $end
$var wire 1 . RegWrite $end
$var wire 64 / ReadDataMem [63:0] $end
$var wire 64 0 ReadData2 [63:0] $end
$var wire 64 1 ReadData1 [63:0] $end
$var wire 64 2 PC_Out [63:0] $end
$var wire 4 3 Operation [3:0] $end
$var wire 7 4 Opcode [6:0] $end
$var wire 64 5 MuxMemOut [63:0] $end
$var wire 64 6 MuxBranchOut [63:0] $end
$var wire 64 7 MuxALUOut [63:0] $end
$var wire 1 8 MemtoReg $end
$var wire 1 9 MemWrite $end
$var wire 1 : MemRead $end
$var wire 1 ; Branch $end
$var wire 64 < Adder2Out [63:0] $end
$var wire 64 = Adder1Out [63:0] $end
$var wire 64 > ALUresult [63:0] $end
$var wire 1 ? ALUSrc $end
$var wire 2 @ ALUOp [1:0] $end
$scope module ALU64 $end
$var wire 64 A B [63:0] $end
$var wire 4 B ALUOp [3:0] $end
$var wire 64 C A [63:0] $end
$var reg 64 D O [63:0] $end
$var reg 1 - Zero $end
$upscope $end
$scope module DMem $end
$var wire 64 E Mem_Addr [63:0] $end
$var wire 1 ! clk $end
$var wire 64 F WriteData [63:0] $end
$var wire 1 9 MemWrite $end
$var wire 1 : MemRead $end
$var reg 64 G Read_Data [63:0] $end
$upscope $end
$scope module Igen $end
$var wire 32 H instruction [31:0] $end
$var wire 64 I immed_value [63:0] $end
$scope module m1 $end
$var wire 64 J A [63:0] $end
$var wire 64 K B [63:0] $end
$var wire 64 L C [63:0] $end
$var wire 2 M S [1:0] $end
$var wire 64 N O [63:0] $end
$upscope $end
$upscope $end
$scope module PC $end
$var wire 64 O PC_In [63:0] $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var reg 64 P PC_Out [63:0] $end
$upscope $end
$scope module ac1 $end
$var wire 4 Q Funct [3:0] $end
$var wire 2 R ALUOp [1:0] $end
$var reg 4 S Operation [3:0] $end
$upscope $end
$scope module add1 $end
$var wire 64 T a [63:0] $end
$var wire 64 U b [63:0] $end
$var wire 64 V c [63:0] $end
$upscope $end
$scope module add2 $end
$var wire 64 W a [63:0] $end
$var wire 64 X b [63:0] $end
$var wire 64 Y c [63:0] $end
$upscope $end
$scope module c1 $end
$var wire 7 Z Opcode [6:0] $end
$var reg 2 [ ALUOp [1:0] $end
$var reg 1 ? ALUSrc $end
$var reg 1 ; Branch $end
$var reg 1 : MemRead $end
$var reg 1 9 MemWrite $end
$var reg 1 8 MemtoReg $end
$var reg 1 . RegWrite $end
$upscope $end
$scope module iMem $end
$var wire 64 \ Inst_address [63:0] $end
$var reg 32 ] Instruction [31:0] $end
$upscope $end
$scope module iParser $end
$var wire 32 ^ instruction [31:0] $end
$var wire 5 _ rs2 [24:20] $end
$var wire 5 ` rs1 [19:15] $end
$var wire 5 a rd [11:7] $end
$var wire 7 b opcode [6:0] $end
$var wire 7 c funct7 [31:25] $end
$var wire 3 d funct3 [14:12] $end
$upscope $end
$scope module muxALUSrc $end
$var wire 64 e B [63:0] $end
$var wire 1 ? S $end
$var wire 64 f O [63:0] $end
$var wire 64 g A [63:0] $end
$upscope $end
$scope module muxBranch $end
$var wire 64 h A [63:0] $end
$var wire 64 i B [63:0] $end
$var wire 1 j S $end
$var wire 64 k O [63:0] $end
$upscope $end
$scope module muxMemory $end
$var wire 64 l A [63:0] $end
$var wire 64 m B [63:0] $end
$var wire 1 8 S $end
$var wire 64 n O [63:0] $end
$upscope $end
$scope module rFile $end
$var wire 1 . RegWrite $end
$var wire 64 o WriteData [63:0] $end
$var wire 1 ! clk $end
$var wire 5 p rd [4:0] $end
$var wire 1 " reset $end
$var wire 5 q rs1 [4:0] $end
$var wire 5 r rs2 [4:0] $end
$var reg 64 s ReadData1 [63:0] $end
$var reg 64 t ReadData2 [63:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 t
b0 s
b1000 r
b1010 q
b1001 p
bz o
b1111111111111111111111111111111111111111111111111111111111010111 n
b1111111111111111111111111111111111111111111111111111111111010111 m
b0xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx l
b100 k
0j
b1010000 i
b100 h
b0 g
b101000 f
b101000 e
b11 d
b1 c
b11 b
b1001 a
b1010 `
b1000 _
b10100001010011010010000011 ^
b10100001010011010010000011 ]
b0 \
b10 [
b11 Z
b1010000 Y
b1010000 X
b0 W
b100 V
b0 U
b100 T
bx S
b10 R
bz Q
b0 P
bz O
b101000 N
b0 M
b10000010100 L
b101001 K
b101000 J
b101000 I
b10100001010011010010000011 H
b0xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx G
b0 F
b1111111111111111111111111111111111111111111111111111111111010111 E
b1111111111111111111111111111111111111111111111111111111111010111 D
b0 C
bx B
b101000 A
b10 @
1?
b1111111111111111111111111111111111111111111111111111111111010111 >
b100 =
b1010000 <
0;
1:
09
18
b101000 7
b100 6
b1111111111111111111111111111111111111111111111111111111111010111 5
b11 4
bx 3
b0 2
b0 1
b0 0
b0xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx /
1.
0-
b11 ,
b1 +
b101000 *
b10100001010011010010000011 )
b1001 (
b1010 '
b1000 &
bz %
bz $
bz #
1"
0!
$end
#5
1!
#10
b1111111111111111111111111111111111111111111111111111111111010101 5
b1111111111111111111111111111111111111111111111111111111111010101 n
b1111111111111111111111111111111111111111111111111111111111010101 >
b1111111111111111111111111111111111111111111111111111111111010101 D
b1111111111111111111111111111111111111111111111111111111111010101 E
b1111111111111111111111111111111111111111111111111111111111010101 m
b1000 0
b1000 F
b1000 g
b1000 t
b1010 1
b1010 C
b1010 s
0!
0"
#15
bx 6
bx k
bx =
bx V
bx h
bx <
bx Y
bx i
bz 2
bz P
bz U
bz W
bz \
1!
#20
0!
#25
1!
#30
0!
#35
1!
#40
0!
#45
1!
#50
0!
